name: Deploy to AWS

on:
  push:
    branches:
      - main
      - staging
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ${{ secrets.AWS_REGION || 'us-east-1' }}
  ECR_BACKEND_REPO: docquery-backend
  ECR_WORKER_REPO: docquery-worker
  ECR_FRONTEND_REPO: docquery-frontend

jobs:
  # Determine environment
  setup:
    name: Setup Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      image_tag: ${{ steps.set-env.outputs.image_tag }}
    steps:
      - name: Determine environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            ENV="production"
          else
            ENV="staging"
          fi
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "image_tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "Deploying to: $ENV"

  # Build and Push Docker Images
  build-push:
    name: Build & Push Images
    runs-on: ubuntu-latest
    needs: setup
    env:
      IMAGE_TAG: ${{ needs.setup.outputs.image_tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_BACKEND_REPO }}:${{ env.IMAGE_TAG }}
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_BACKEND_REPO }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push worker image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_WORKER_REPO }}:${{ env.IMAGE_TAG }}
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_WORKER_REPO }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          build-args: |
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_FRONTEND_REPO }}:${{ env.IMAGE_TAG }}
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_FRONTEND_REPO }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Deploy to ECS
  deploy-ecs:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    needs: [setup, build-push]
    env:
      ENVIRONMENT: ${{ needs.setup.outputs.environment }}
      IMAGE_TAG: ${{ needs.setup.outputs.image_tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update ECS services
        run: |
          CLUSTER="docquery-cluster-${{ env.ENVIRONMENT }}"
          API_SERVICE="docquery-api-${{ env.ENVIRONMENT }}"
          WORKER_SERVICE="docquery-worker-${{ env.ENVIRONMENT }}"
          FRONTEND_SERVICE="docquery-frontend-${{ env.ENVIRONMENT }}"

          echo "Deploying to cluster: $CLUSTER"

          # Force new deployment for API service
          aws ecs update-service \
            --cluster "$CLUSTER" \
            --service "$API_SERVICE" \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

          # Force new deployment for Worker service
          aws ecs update-service \
            --cluster "$CLUSTER" \
            --service "$WORKER_SERVICE" \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

          # Force new deployment for Frontend service (if exists)
          aws ecs update-service \
            --cluster "$CLUSTER" \
            --service "$FRONTEND_SERVICE" \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }} || echo "Frontend service not found, skipping"

      - name: Wait for deployment stability
        run: |
          CLUSTER="docquery-cluster-${{ env.ENVIRONMENT }}"
          API_SERVICE="docquery-api-${{ env.ENVIRONMENT }}"

          echo "Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster "$CLUSTER" \
            --services "$API_SERVICE" \
            --region ${{ env.AWS_REGION }} || true

  # Deploy to EC2 (Alternative)
  deploy-ec2:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: [setup, build-push]
    if: vars.DEPLOY_METHOD == 'ec2'
    env:
      ENVIRONMENT: ${{ needs.setup.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy via SSM Run Command
        run: |
          INSTANCE_ID="${{ secrets.EC2_INSTANCE_ID }}"

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /home/ubuntu/docquery",
              "git fetch origin",
              "git checkout ${{ github.ref_name }}",
              "git pull origin ${{ github.ref_name }}",
              "docker-compose down",
              "docker-compose pull",
              "docker-compose up -d --build",
              "docker-compose exec -T backend python scripts/init_db.py"
            ]' \
            --output text \
            --query "Command.CommandId")

          echo "Command ID: $COMMAND_ID"

          # Wait for command completion
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID"

          # Get command output
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "StandardOutputContent" \
            --output text

  # Health Check
  health-check:
    name: Post-Deployment Health Check
    runs-on: ubuntu-latest
    needs: [setup, deploy-ecs]
    if: always() && needs.deploy-ecs.result == 'success'
    env:
      ENVIRONMENT: ${{ needs.setup.outputs.environment }}

    steps:
      - name: Wait for deployment
        run: sleep 30

      - name: Health check - API
        run: |
          API_URL="${{ secrets.API_URL }}"
          if [ -z "$API_URL" ]; then
            echo "⚠️ API_URL not set, skipping health check"
            exit 0
          fi

          MAX_RETRIES=5
          RETRY=0

          while [ $RETRY -lt $MAX_RETRIES ]; do
            if curl -f -s "${API_URL}/health" | jq -e '.status == "healthy"' > /dev/null; then
              echo "✅ Health check passed"
              exit 0
            fi
            RETRY=$((RETRY+1))
            echo "Health check attempt $RETRY failed, retrying..."
            sleep 10
          done

          echo "❌ Health check failed after $MAX_RETRIES attempts"
          exit 1

      - name: Health check - Frontend
        run: |
          FRONTEND_URL="${{ secrets.FRONTEND_URL }}"
          if [ -z "$FRONTEND_URL" ]; then
            echo "⚠️ FRONTEND_URL not set, skipping health check"
            exit 0
          fi

          if curl -f -s "$FRONTEND_URL" > /dev/null; then
            echo "✅ Frontend is accessible"
          else
            echo "⚠️ Frontend health check failed"
          fi

  # Database Migration (Optional)
  database-migration:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    needs: [setup, build-push]
    if: vars.RUN_MIGRATIONS == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Run migrations via ECS Task
        run: |
          # Run Alembic migrations as a one-off ECS task
          aws ecs run-task \
            --cluster "docquery-cluster-${{ needs.setup.outputs.environment }}" \
            --task-definition "docquery-migration-task" \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[${{ secrets.PRIVATE_SUBNET_IDS }}],securityGroups=[${{ secrets.ECS_SECURITY_GROUP }}]}" \
            --region ${{ env.AWS_REGION }} || echo "Migration task not configured"

  # Invalidate CloudFront (if using)
  invalidate-cloudfront:
    name: Invalidate CloudFront
    runs-on: ubuntu-latest
    needs: [setup, deploy-ecs, health-check]
    if: always() && needs.health-check.result == 'success' && secrets.CLOUDFRONT_DISTRIBUTION_ID != ''

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create CloudFront invalidation
        run: |
          aws cloudfront create-invalidation \
            --distribution-id "${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}" \
            --paths "/*" \
            --region us-east-1

  # Rollback on Failure
  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [setup, deploy-ecs, health-check]
    if: failure() && needs.setup.outputs.environment == 'production'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Trigger rollback
        run: |
          echo "⚠️ Deployment failed, triggering rollback..."
          CLUSTER="docquery-cluster-${{ needs.setup.outputs.environment }}"

          # Revert to previous task definition
          aws ecs update-service \
            --cluster "$CLUSTER" \
            --service "docquery-api-${{ needs.setup.outputs.environment }}" \
            --task-definition "docquery-api:PREVIOUS" \
            --force-new-deployment || true

  # Notify
  notify:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs: [setup, deploy-ecs, health-check]
    if: always()

    steps:
      - name: Deployment status
        run: |
          if [ "${{ needs.health-check.result }}" == "success" ]; then
            STATUS="✅ SUCCESS"
            COLOR="good"
          else
            STATUS="❌ FAILED"
            COLOR="danger"
          fi

          echo "Deployment Status: $STATUS"
          echo "Environment: ${{ needs.setup.outputs.environment }}"
          echo "Commit: ${{ github.sha }}"

      - name: Send Slack notification
        if: secrets.SLACK_WEBHOOK_URL != ''
        run: |
          STATUS="${{ needs.health-check.result }}"
          if [ "$STATUS" == "success" ]; then
            EMOJI=":white_check_mark:"
            COLOR="good"
          else
            EMOJI=":x:"
            COLOR="danger"
          fi

          curl -X POST "${{ secrets.SLACK_WEBHOOK_URL }}" \
            -H 'Content-Type: application/json' \
            -d '{
              "text": "'"$EMOJI"' DocQuery Deployment",
              "attachments": [{
                "color": "'"$COLOR"'",
                "fields": [
                  {"title": "Status", "value": "'"$STATUS"'", "short": true},
                  {"title": "Environment", "value": "${{ needs.setup.outputs.environment }}", "short": true},
                  {"title": "Branch", "value": "${{ github.ref_name }}", "short": true},
                  {"title": "Commit", "value": "${{ github.sha }}", "short": true}
                ]
              }]
            }'
